---
layout: single
title:  "Google Antigravity 활용하기"
---

# Antigravity 기능 활용

Google Antigravity를 처음 써보면서 몇 가지 기능들을 테스트해 보았다.


<br/><br/>


# 1. Artifacts 기반 검증 – 신뢰할 수 있는 작업 흐름 활용해보기

우선 녹화 영상 남기는 것, 테스트 결과를 남기는 것, 코멘트를 달아서 피드백 해보기 등을 시도해보고 중간 과정을 잘 표시하는지를 확인하기 위해
이 깃허브 블로그를 활용해서 다크 모드/라이트 모드 선택이 가능한 기능을 만들어달라고 요구했다.

<br/>

## 🛠 명령어
내 사이트(https://lectior0902.github.io/)의 다크 모드 디자인 가이드라인을 분석하고, 이를 바탕으로 간단한 ThemeSwitcher 컴포넌트를 설계한 뒤 설계 문서를 작성해줘.

<br/>

이에 따라 Antigravity는 브라우저를 열어 블로그를 분석하고 설계 문서를 작성하는 과정에서 녹화 영상을 남겼으며
나의 요구에 따른 과제를 정리하기 위한 task.md파일과 아래와 같은 design_document.md 파일을 생성하였다.


# ThemeSwitcher Design Document

## 1. 개요 (Overview)
본 문서는 [https://lectior0902.github.io/](https://lectior0902.github.io/) 사이트에 **다크 모드(Dark Mode)** 기능을 도입하기 위한 디자인 가이드라인 및 기술 설계 문서입니다. 기존 사이트의 미니멀한 디자인 철학을 유지하면서, 사용자의 시스템 설정을 존중하고 수동으로 테마를 전환할 수 있는 `ThemeSwitcher` 컴포넌트를 설계합니다.

## 2. 디자인 시스템 분석 (Design Analysis)

### 2.1 기존 스타일 (Light Mode)
현재 사이트는 "Minimal Mistakes" Jekyll 테마 기반의 깔끔한 화이트 톤 디자인을 유지하고 있습니다.
- **Background**: `#ffffff` (White)
- **Primary Text**: `#3d4144` (Charcoal Grey)
- **Secondary Text**: `#6f777d` (Ash Grey)
- **Link/Accent**: `#2f7d95` (Muted Teal)
- **Border/Divider**: `#f2f3f3` (Light Grey)

### 2.2 다크 모드 제안 (Dark Mode Proposal)
기존의 Teal 포인트 컬러와 조화를 이루는 **Deep Navy** 또는 **Neutral Dark Grey** 기반의 팔레트를 제안합니다. 완전한 블랙(`#000000`)보다는 눈의 피로를 줄일 수 있는 어두운 회색조를 사용합니다.

| 구분 | Light Mode (Current) | Dark Mode (Proposed) | 비고 |
| :--- | :--- | :--- | :--- |
| **Background** | `#ffffff` | `#1d212f` | 다크 네이비 베이스 |
| **Surface** | `#f2f3f3` | `#282c3a` | 카드/섹션 배경 |
| **Text (Main)** | `#3d4144` | `#e1e3e5` | 높은 가독성 확보 |
| **Text (Sub)** | `#6f777d` | `#a5a9ad` | 대비 낮춤 |
| **Accent/Link** | `#2f7d95` | `#4fb3d0` | 기존보다 밝은 톤 |
| **Border** | `#eeeeee` | `#3b404e` | 경계선 |

## 3. 기술 설계 (Technical Architecture)

### 3.1 CSS Variables (Custom Properties) 전략
기존의 하드코딩된 색상 값을 CSS 변수로 치환하여 유연한 테마 전환을 지원합니니다.

```css
:root {
    --bg-color: #ffffff;
    --text-main: #3d4144;
    --text-sub: #6f777d;
    --accent-color: #2f7d95;
    --border-color: #f2f3f3;
}

[data-theme="dark"] {
    --bg-color: #1d212f;
    --text-main: #e1e3e5;
    --text-sub: #a5a9ad;
    --accent-color: #4fb3d0;
    --border-color: #3b404e;
}

body {
    background-color: var(--bg-color);
    color: var(--text-main);
    transition: background-color 0.3s ease, color 0.3s ease;
}
```

### 3.2 ThemeSwitcher 컴포넌트 설계

#### **기능 요구사항**
1.  **Toggle Switch**: 클릭 시 Light/Dark 모드가 즉시 전환되어야 함.
2.  **Persistence**: 사용자의 선택을 `localStorage`에 저장하여 재방문 시 유지.
3.  **System Preference**: 최초 방문 시 사용자의 OS 설정(`prefers-color-scheme`)을 따름.
4.  **No FOUC**: 페이지 로드 시 깜빡임(Flash of Unstyled Content) 방지.

#### **UI 디자인**
- **위치**: 우측 상단 네비게이션 바 혹은 우측 하단 플로팅 버튼.
- **아이콘**: ☀️ (Sun) / 🌙 (Moon) 아이콘을 사용하여 직관적으로 표현.
- **인터랙션**: 부드러운 아이콘 전환 애니메이션 적용.

### 3.3 로직 흐름도 (Logic Flow)
1.  **Init**: 페이지 로드 시 스크립트 실행 (`<head>` 내부).
    - `localStorage` 확인 → 값 있으면 적용.
    - 없으면 `window.matchMedia('(prefers-color-scheme: dark)')` 확인 → 적용.
    - `documentElement`에 `data-theme="dark"` 속성 부여.
2.  **User Action**: 버튼 클릭.
    - 테마 반전 (Light ↔ Dark).
    - `data-theme` 속성 업데이트.
    - `localStorage`에 변경된 값 저장.

## 4. 구현 가이드 (Implementation Steps)

### Step 1: CSS 변수 적용
`main.css` (또는 SCSS 파일)에서 색상 코드를 찾아 변수로 교체합니다.

### Step 2: JavaScript 로직 작성
FOUC 방지를 위해 `<head>` 태그 내에 초기화 스크립트를 삽입하고, `ThemeSwitcher` 컴포넌트(버튼)의 이벤트 리스너는 `</body>` 직전에 배치하거나 `DOMContentLoaded` 이벤트를 사용합니다.

```javascript
// init-theme.js (place in <head>)
(function() {
  const savedTheme = localStorage.getItem('theme');
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
    document.documentElement.setAttribute('data-theme', 'dark');
  } else {
    document.documentElement.removeAttribute('data-theme');
  }
})();
```

### Step 3: UI 컴포넌트 추가
HTML 구조에 버튼을 추가합니다.
```html
<button id="theme-toggle" aria-label="Toggle Dark Mode">
  <svg class="sun-icon">...</svg>
  <svg class="moon-icon">...</svg>
</button>
```

---
이 설계 문서는 현재 사이트의 구조를 해치지 않으면서 가장 효율적으로 다크 모드를 도입할 수 있는 방법을 제시합니다.

<br/><br/>

결과적으로 문서에 따라 깃허브에 적용해보니 

<img width="819" height="260" alt="image" src="https://github.com/user-attachments/assets/9d78687b-0700-43a9-8d4c-e3e660df15c1" />

<img width="819" height="260" alt="image" src="https://github.com/user-attachments/assets/b945d497-ad16-4bb5-9afd-fd9c8ccfbbd7" />

<br/>

위와 같이 다크 모드/라이트 모드로 변환할 수 있는 기능을 추가해볼 수 있도록 설계 문서가 잘 작성이 된 것을 확인해볼 수 있었다.


<br/><br/>


# 2. 브라우저 통합 – Chrome에서 자동 UI 테스트 해보기

<br/>

## 🛠 초기 명령어

Chrome 확장을 설치했기 때문에 브라우저를 잘 제어하는지, UI테스트 자동화를 잘 수행하는지 테스트해보려고 해.
localhost:4000 등 chrome을 기반으로 한 로컬 호스트 주소에 접속해서 다음 시나리오로 UI 테스트를 수행하고 보고서를 작성해줘:

1. 메인 페이지의 '로그인' 버튼을 클릭한다.

2. 잘못된 이메일 형식(예: test@invalid)을 입력하고 '비밀번호' 필드에 아무 값이나 넣는다.

3. '제출' 버튼을 눌렀을 때 '올바른 이메일 형식이 아닙니다'라는 에러 메시지가 붉은색으로 뜨는지 확인한다.

이러한 전체 과정을 영상으로 녹화하고, 에러 메시지가 뜬 순간의 스크린샷을 하나 남겨줘.

<br/>

이와 같은 과정을 거치려면 Ruby 언어와 Bundler 패키지 매니저를 필요로 하기 때문에 테스트 페이지를 이용해서 브라우저 UI 테스트를 진행해보았다.

<br/>

## 🛠 수정 명령어

테스트 사이트인 https://the-internet.herokuapp.com/login 에 접속해서 UI 테스트를 수행해줘.
유저네임에 tomsmith, 비밀번호에 SuperSecretPassword!를 입력하고 Login 버튼을 눌러줘. (폼 입력 및 클릭)

로그인이 성공하면 'Secure Area'라는 문구가 뜨는지 확인해.
그 후 https://the-internet.herokuapp.com/infinite_scroll 로 이동해서 화면을 아래로 3번 정도 스크롤하며 새로운 콘텐츠가 로드되는지 확인해줘.

이 과정을 녹화하고, Secure Area 문구가 뜨는 순간을 캡쳐해줘

<br/>

Login 과정:

1) 
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/e8bea54f-14b9-4337-93cb-1a2fec472c7a" />

2) 
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/0627b408-d15e-48c8-a411-f3d85e65ad7a" />

3) 
<img width="940" height="529" alt="image" src="https://github.com/user-attachments/assets/1d6096e1-90fe-4314-900c-a0d54707a721" />


Scroll 과정: https://the-internet.herokuapp.com/infinite_scroll


최종 스크린샷: <img width="506" height="474" alt="image" src="https://github.com/user-attachments/assets/312f9f12-77f2-43e2-8967-7f5b1cec9a86" />



<br/>

## 🧪 UI 테스트 자동화 핵심 기능

로컬 환경 설정(Ruby, Jekyll 등)의 복잡함 없이, **Google Antigravity** 에이전트를 활용해 실제 웹사이트에서 **버튼 클릭, 폼 입력, 스크롤** 기능을 검증

## 1. 개요
기존의 UI 테스트(Selenium, Cypress)는 복잡한 셀렉터 설정과 로컬 환경 구축이 필수적이었으나, Antigravity 에이전트는 자연어 지시만으로 브라우저를 직접 제어하여 테스트를 수행

### 📊 기능별 매핑 가이드

테스트 전용 사이트인 [The Internet](https://the-internet.herokuapp.com/)을 대상으로 한 기능 검증 매핑입니다.

| 테스트 기능 | 실전 프롬프트 명령 예시 | 에이전트 내부 동작 및 메커니즘 |
| :--- | :--- | :--- |
| **폼 입력 (Input)** | "유저네임에 `tomsmith`, 비밀번호에 `SuperSecretPassword!`를 입력해줘" | `input` 요소를 식별하여 포커스를 이동시키고, 실제 키보드 타이핑 이벤트를 시뮬레이션 |
| **버튼 클릭 (Click)** | "`Login` 버튼을 눌러줘" | 요소의 좌표를 계산하여 정확한 위치에 마우스 클릭 이벤트를 발생시키며, 페이지 전환 완료 시까지 자동 대기 |
| **스크롤 (Scroll)** | "`infinite_scroll` 페이지로 이동해서 화면을 아래로 3번 정도 스크롤해줘" | `window.scrollTo` 이벤트를 발생시켜 뷰포트 밖의 콘텐츠를 로드하고, 새로운 요소의 생성 여부를 관찰 |

---
<br/>

### 🔍 인사이트

1. **지능적 상태 판단 (Intelligent State Awareness)**
   - 에이전트는 단순히 명령을 순차 실행하는 것이 아니라, "로그인 성공 여부"를 시각적으로 확인한 뒤 다음 단계(스크롤 테스트)로 넘어가는 판단력을 보여줌.

2. **시각적 증거물 (Artifacts as Evidence)**
   - 에이전트가 생성한 **브라우저 녹화 영상**과 **에러 스크린샷**은 텍스트 로그보다 강력한 디버깅 증거로 활용됨.

---

<br/><br/>


# 3. Planning 모드 vs Fast 모드 비교


**테스트 시나리오"**

짧은 코드를 두 개의 에이전트에 실행해보기

1) Fast mode
---
function 계산(a, b) {
  return a + b;
}
---

위의 계산 함수를 Arrow Function으로 바꾸고, 입력값이 숫자가 아니면 0을 반환하는 예외 처리를 추가해서 파일로 저장해줘. 계획 세우지 말고 바로 코드만 짜줘.

**속도: 1분 미만 소요. 시작 시간: 01:26:01, 01:27:00 경 완료. 코드를 작성하고 작업을 완료하는 데 1분 미만(실제 처리 시간 수 초 이내), 과정 표시 없음** 


2) Planning mode
---
function 계산(a, b) {
  return a + b;
}
---

위의 계산 함수를 Arrow Function으로 바꾸고, 입력값이 숫자가 아니면 0을 반환하는 예외 처리를 추가해서 파일로 저장해줘.

**속도: 약 15분 24초가 소요. 시작 시간: 01:27:06, 현재 시간: 01:42:30, 계획 수립 및 수정, 사고의 전 과정 출력**


### 🔍 인사이트

코드 작성 및 계산 측면에서는 fast mode가 처리 효율 측면에서 뛰어남.
계획 모드는 신중한 검토와 단계별 진행을 위해 더 많은 시간이 소요되지만, 복잡한 작업에서 안정성을 높이는 데 유리.

## 📊 Planning 모드 vs Fast 모드 비교

| 비교 항목 | Fast 모드 (Quick & Dirty) | Planning 모드 (Deliberate) |
| :--- | :--- | :--- |
| **응답 속도** | **즉시 실행 (매우 빠름)** | 계획 수립 시간 필요 (상대적 느림) |
| **논리적 완결성** | 단순 변환에 강함, 복합 조건 누락 가능성 있음 | 모든 제약 조건을 체크리스트화하여 완벽하게 처리 |
| **추천 용도** | 오타 수정, 변수명 변경, 간단한 UI 클릭 | 로직 리팩토링, 신규 아키텍처 설계, 복잡한 테스트 |


<br/><br/>

# 4. Agent Manager & 미션 컨트롤 (병렬 에이전트 운용)

아래 사진과 같은 방식으로 소스 코드를 인식시키고 3개의 태스크를 동시에 실행하였다.

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/74b6da0a-73ce-4e6f-ba8b-e81c4e465ccc" />

<br/>

### 🖥 Agent Manager: 병렬 에이전트 협업 분석

| 에이전트 | 담당 역할 (Role) | 주요 성과 (Artifacts) | 비고 |
| :--- | :--- | :--- | :--- |
| **Agent A** | **Refactoring** | `MathTool.js` (클래스 변환) | 구조적 개선 담당 |
| **Agent B** | **Unit Testing** | `MathTool.test.js` | 품질 검증 담당 |
| **Agent C** | **Documentation** | `README.md` | 사용자 가이드 작성 |

---

### 🔍 인사이트
- **병렬성**: 순차적으로 채팅을 주고받던 기존 방식보다 작업 시간이 약 **3배 단축**됨.
- **오케스트레이션**: 사용자는 대시보드에서 각 에이전트의 진행 상태를 실시간으로 모니터링하며 '팀 리더' 역할을 수행함.
- **협업 품질**: 동일한 소스를 공유하며 각기 다른 관점(코드, 테스트, 문서)에서 결과물을 동시 생성하여 일관성 확보.

