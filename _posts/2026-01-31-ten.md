

---
layout: single
title:  "26.01.26. 데일리미션: 데이터 시각화 실습 part"
---



# 26.01.26 데일리미션





```python
from google.colab import drive
drive.mount('/content/drive')
```

    Mounted at /content/drive



```python
!jupyter nbconvert --to markdown "/content/drive/MyDrive/구름 생성AI/구름exp/26.01.26 데일리미션.ipynb"
```

# **Pandas 데이터프레임 만들기**


```python
import numpy as np
import pandas as pd
```

```
< pandas 데이터프레임 >
- data: ndarray, iterable(list, tuple) dict[열의 순서는 삽입순], DataFrame
- index: 인스턴스에 설정되는 "행" 레이블, 인덱스 또는 배열 형태
- columns: 인스턴스에 설정되는 "열" 레이블, 인덱스 또는 배열 형태
- dtype: 기본값 - None, 데이터 유형을 강제하고자 할 때의 값
- copy : bool
```

## **1. ndarray와 index, columns를 지정**


```python
# 데이터 만들기(ndarray 활용)
arr = np.array([[10, 20], [30, 40]])

# 데이터프레임 생성
# index: 행 레이블, columns: 열 레이블
df = pd.DataFrame(data=arr,
                  index=['row1', 'row2'],
                  columns=['col_A', 'col_B'],
                  dtype=float  # 데이터 유형: 실수형으로
)

print("--- 데이터프레임 ---")
print(df)
```

    --- 데이터프레임 ---
          col_A  col_B
    row1   10.0   20.0
    row2   30.0   40.0


## **2. dict를 이용한 생성 (열 순서 삽입순)**


```python
arr = {'Name': ['Kelly', 'Emma'],'Age': [26, 24]}

df = pd.DataFrame(data=arr)
print("--- Dictionary 데이터프레임 ---")
print(df)
```

    --- Dictionary 데이터프레임 ---
        Name  Age
    0  Kelly   26
    1   Emma   24


#**Pandas 사칙연산 수행하기**
- fill_value 활용


```python
# 데이터프레임
df1 = pd.DataFrame([[1, 2], [3, 4]], columns=['col1', 'col2'])
df2 = pd.DataFrame([[1], [1]], columns=['col1'])                  # col2가 없음
```


```python
print(df1)
```

       col1  col2
    0     1     2
    1     3     4



```python
print(df2)
```

       col1
    0     1
    1     1



```python
# 1. 덧셈 (add): 존재하지 않는 컬럼은 NaN으로 표시됨, fill_value 활용해보기
# df1 + df2
result_add = df1.add(df2, fill_value=0)

print("--- fill_value를 활용한 덧셈 결과 ---")
print(result_add)
```

    --- fill_value를 활용한 덧셈 결과 ---
       col1  col2
    0     2   2.0
    1     4   4.0



```python
# 2. 나눗셈 (div): 0으로 나누는 경우 등을 대비해 유용
result_div = df1.div(2)

print("--- 2로 나눈 결과 ---")
print(result_div)
```

    --- 2로 나눈 결과 ---
       col1  col2
    0   0.5   1.0
    1   1.5   2.0



```python
# 3. 거듭제곱 (pow): 머신러닝 비용함수 계산 시 오차 제곱 등에 자주 쓰임
result_pow = df1.pow(2)

print("--- 2제곱 결과 ---")
print(result_pow)
```

    --- 2제곱 결과 ---
       col1  col2
    0     1     4
    1     9    16


#**Pandas 기타연산 메서드 활용하기**

##**행렬 연산 기타 연산**


```python
# 데이터세트 만들기
# 행: 사용자(User), 열: Influence, Trust
df = pd.DataFrame({'Influence': [90, 80, 70, 80], 'Trust': [85, 95, 70, 60]},
                  index=['User_A', 'User_B', 'User_C', 'User_D'])

print("--- 데이터프레임 ---")
print(df)
```

    --- 데이터프레임 ---
            Influence  Trust
    User_A         90     85
    User_B         80     95
    User_C         70     70
    User_D         80     60



```python
# 행렬곱
# 가중치 주듯이 Influence 40%, Trust 60%으로 설정
weights = pd.DataFrame([0.4, 0.6], index=['Influence', 'Trust'], columns=['Weight'])

print("--- weights ---")
print(weights)

# 가중치를 반영한 행렬곱 결과 (Influence * 0.4) + (Trust * 0.6)
result = df.dot(weights)

print("\n")
print("--- result ---")
print(result)
```

    --- weights ---
               Weight
    Influence     0.4
    Trust         0.6
    
    
    --- result ---
            Weight
    User_A    87.0
    User_B    89.0
    User_C    70.0
    User_D    68.0



```python
# rank(순위) - Influence 기준으로 rank 매기기

# method = 'dense': 같은 점수라도 순위를 건너뛰지 않는 방식으로 해보기
# 같은 점수는 공동 순위가 되고, 그 다음은 바로 아래 순위가 됨

print("--- Influence 순위 ---")

rank_result = df['Influence'].rank(method='dense', ascending=False)
print(rank_result)
print("\n")


# 전치(T) - 행과 열 전환
# 원본 데이터세트를 기준으로 Influence, Trust 등의 변수가 더 잘 보이도록 전치해보기


print("--- 데이터 전치 ---")

transpose = df.T
print(transpose)
```

    --- Influence 순위 ---
    User_A    1.0
    User_B    2.0
    User_C    3.0
    User_D    2.0
    Name: Influence, dtype: float64
    
    
    --- 데이터 전치 ---
               User_A  User_B  User_C  User_D
    Influence      90      80      70      80
    Trust          85      95      70      60


##**시계열 데이터 기타 연산**


```python
# 시계열 데이터세트 만들기
# 2026-01-10부터 5일간의 날짜 생성

dates = pd.date_range(start='2026-01-10', periods=5)
time_data = pd.DataFrame({'val': [1, 2, 4, 8, 16]}, index=dates)

print("--- 데이터프레임 ---")
print(time_data)
```

    --- 데이터프레임 ---
                val
    2026-01-10    1
    2026-01-11    2
    2026-01-12    4
    2026-01-13    8
    2026-01-14   16



```python
# 차이 계산 (diff): 전일 대비 수치상으로 얼마나 올랐는지 등을 확인해볼 수 있음
# 예를 들어, 1월 11일 값(2) - 1월 10일 값(1) = 1.0이 나와야 함

result = time_data.diff(periods=1)
print("--- 차이 계산 (diff) 데이터세트 ---")
print(result)
print("\n")

# 변화율 계산 (pct_change): 전일 대비 몇 %나 변했는지 등을 확인해볼 수 있음
# 예를 들어, (1월 11일 값 - 1월 10일 값) / 1월 10일 값 = 1.0이므로 100% 상승

result2 = time_data.pct_change()
print("--- [2] 변화율 계산 (pct_change, 수익률) ---")
print(result2)
print("\n")


# 기간이동 평균 (Rolling): 최근 3일간의 평균 확인해보기
# 1월 12일까지를 기준으로 (1월 10일+1월 11일+1월 12일)/3 = (1+2+4)/3 = 2.33이 평균

avg = time_data.rolling(window=3).mean()
print("--- 3일동안의 이동 평균 (Rolling) ---")
print(avg)
print("\n")


# 누적 합계 (Expanding): 처음 날짜인 10일부터 마지막 날인 14일까지의 총합
# 1월 14일 기준: 1월 10일+1월 11일+1월 12일+1월 13일+1월 14일 = 1+2+4+8+16 = 31.0

expanding_sum = time_data.expanding().sum()
print("--- 누적 합계 (Expanding) ---")
print(expanding_sum)
```

    --- 차이 계산 (diff) 데이터세트 ---
                val
    2026-01-10  NaN
    2026-01-11  1.0
    2026-01-12  2.0
    2026-01-13  4.0
    2026-01-14  8.0
    
    
    --- [2] 변화율 계산 (pct_change, 수익률) ---
                val
    2026-01-10  NaN
    2026-01-11  1.0
    2026-01-12  1.0
    2026-01-13  1.0
    2026-01-14  1.0
    
    
    --- 3일동안의 이동 평균 (Rolling) ---
                     val
    2026-01-10       NaN
    2026-01-11       NaN
    2026-01-12  2.333333
    2026-01-13  4.666667
    2026-01-14  9.333333
    
    
    --- 누적 합계 (Expanding) ---
                 val
    2026-01-10   1.0
    2026-01-11   3.0
    2026-01-12   7.0
    2026-01-13  15.0
    2026-01-14  31.0

