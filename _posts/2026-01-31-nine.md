---
layout: single
title:  "26.01.26. 데일리미션: 데이터 시각화 개념정리 part"
---

# 줌 강의 개념정리(~기간이동 계산 (rolling))


```python
from google.colab import drive
drive.mount('/content/drive')
```


```python
!jupyter nbconvert --to markdown "/content/drive/MyDrive/구름 생성AI/줌 강의/26.01.26 줌 강의 개념정리.ipynb"
```

# **Pandas.DataFrame 클래스 기본**


```python
# Numpy, Pandas 패키지 불러오기
import numpy as np
import pandas as pd
```


```python
# pandas 데이터프레임으로
# data: ndarray, iterable(list, tuple) dict[열의 순서는 삽입순], DataFrame
# index: 인스턴스에 설정되는 "행" 레이블, 인덱스 또는 배열 형태
# columns: 인스턴스에 설정되는 "열" 레이블, 인덱스 또는 배열 형태
# dtype: 기본값 - None, 데이터 유형을 강제하고자 할 때의 값
# copy : bool

pd.DataFrame(data=None, index=None, columns=None, copy=None)
```



```python
# True일 경우: Dataframe의 원본 데이터를 수정하더라도 인스턴스가 변경되지 않음
# False일 경우: 원본데이터를 수정할 시 인스턴스의 값도 바뀌게 됨

np.random.seed(0)
arr = np.random.randint(10, size=(2, 2))          # 0부터 10까지 랜덤한 숫자가 들어간 2*2의 random array 생성
print(arr)
```

    [[5 0]
     [3 3]]



```python
df1 = pd.DataFrame(arr, copy=False)
df2 = pd.DataFrame(arr, copy=True)
```


```python
arr[0,0] = 99
print(df1)
```

        0  1
    0  99  0
    1   3  3



```python
print(df2)                    # 처음 삽입했던 arr값이 그대로
```

       0  1
    0  5  0
    1  3  3



```python
# dict 타입으로 2차원으로 배열하면 data만 설정해주어도 dataframe이 생성!
data = {'A' : [1,2], 'B': [3,4]}
df = pd.DataFrame(data=data)
print(df)
```

       A  B
    0  1  3
    1  2  4



```python
# index(행), column(열) 설정
data = np.array([[1,2,], [3,4]])
df = pd.DataFrame(data=data, index=['row1','row2'], columns=['col1', 'col2'])
print(df)
```

          col1  col2
    row1     1     2
    row2     3     4


#**덧셈 (add, radd)**
- fill_value 인수를 통해 계산 불가한 값을 채워넣음
- radd의 경우 add의 경우에서 순서만 바꾼 것(add가 'df+df2'라면 radd는 'df2+df')
- 역행렬처럼 reverse의 r을 생각하면 될 듯


```python
# other: 데이터프레임, series, 스칼라(대충 실수) 등 데이터가 올 수 있음
# axis: 더할 레이블을 설정. 0은 행, 1은 열(Series일 경우 Index와 일치시킬 축)
# level: multiIndex에서 계산할 Index의 레벨
# fill_value: NaN 등의 누락 요소를 계산 전에 이 값으로 대체

df.add(2, axis='columns', level=None, fill_value=None)
```





  <div id="df-3eae663a-dfd7-4847-a0dd-fdef0e832b9c" class="colab-df-container">
    <div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>col1</th>
      <th>col2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>row1</th>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>row2</th>
      <td>5</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
    <div class="colab-df-buttons">

  <div class="colab-df-container">
    <button class="colab-df-convert" onclick="convertToInteractive('df-3eae663a-dfd7-4847-a0dd-fdef0e832b9c')"
            title="Convert this dataframe to an interactive table."
            style="display:none;">

  <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960">
    <path d="M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z"/>
  </svg>
    </button>

  <style>
    .colab-df-container {
      display:flex;
      gap: 12px;
    }

    .colab-df-convert {
      background-color: #E8F0FE;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: none;
      fill: #1967D2;
      height: 32px;
      padding: 0 0 0 0;
      width: 32px;
    }

    .colab-df-convert:hover {
      background-color: #E2EBFA;
      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);
      fill: #174EA6;
    }

    .colab-df-buttons div {
      margin-bottom: 4px;
    }

    [theme=dark] .colab-df-convert {
      background-color: #3B4455;
      fill: #D2E3FC;
    }

    [theme=dark] .colab-df-convert:hover {
      background-color: #434B5C;
      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));
      fill: #FFFFFF;
    }
  </style>

    <script>
      const buttonEl =
        document.querySelector('#df-3eae663a-dfd7-4847-a0dd-fdef0e832b9c button.colab-df-convert');
      buttonEl.style.display =
        google.colab.kernel.accessAllowed ? 'block' : 'none';

      async function convertToInteractive(key) {
        const element = document.querySelector('#df-3eae663a-dfd7-4847-a0dd-fdef0e832b9c');
        const dataTable =
          await google.colab.kernel.invokeFunction('convertToInteractive',
                                                    [key], {});
        if (!dataTable) return;

        const docLinkHtml = 'Like what you see? Visit the ' +
          '<a target="_blank" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'
          + ' to learn more about interactive tables.';
        element.innerHTML = '';
        dataTable['output_type'] = 'display_data';
        await google.colab.output.renderOutput(dataTable, element);
        const docLink = document.createElement('div');
        docLink.innerHTML = docLinkHtml;
        element.appendChild(docLink);
      }
    </script>
  </div>


    </div>
  </div>





```python
data = [[1,10,100],[2,20,200],[3,30,300]]
col = ['col1','col2','col3']
row = ['row1','row2','row3']
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1    10   100
    row2     2    20   200
    row3     3    30   300



```python
# 위의 데이터프레임에 스칼라값 1을 더하기

result = df.add(1)
print(result)
```

          col1  col2  col3
    row1     2    11   101
    row2     3    21   201
    row3     4    31   301



```python
# 위처럼 add함수를 이용할 수도 있고 바로 데이터프레임에 스칼라값을 더할 수도 있음

result = df+1
print(result)
```

          col1  col2  col3
    row1     2    11   101
    row2     3    21   201
    row3     4    31   301



```python
# 3 X 1 데이터프레임

data2  = [[3],[4],[5]]
df2 = pd.DataFrame(data=data2,index=['row1','row2','row3'],columns=['col1'])
print(df2)
```

          col1
    row1     3
    row2     4
    row3     5



```python
# 데이터프레임 간 덧셈(df2에 없는 열은 NaN이 됨)

result = df.add(df2)
print(result)
```

          col1  col2  col3
    row1     4   NaN   NaN
    row2     6   NaN   NaN
    row3     8   NaN   NaN



```python
# fill_value: Nan 값을 fill_value값인 0으로 바꾸어서 더할 수 있게 됨

result = df.add(df2,fill_value=0)
print(result)
```

          col1  col2   col3
    row1     4  10.0  100.0
    row2     6  20.0  200.0
    row3     8  30.0  300.0


#**뺄셈 (sub, rsub)**
- 덧셈과 함수의 구성요소는 거의 동일


```python
# 3 X 3 데이터프레임

data = [[1,10,100],[2,20,200],[3,30,300]]
col = ['col1','col2','col3']
row = ['row1','row2','row3']
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1    10   100
    row2     2    20   200
    row3     3    30   300



```python
result = df.sub(1)
print(result)
```

          col1  col2  col3
    row1     0     9    99
    row2     1    19   199
    row3     2    29   299



```python
result = df-1
print(result)
```

          col1  col2  col3
    row1     0     9    99
    row2     1    19   199
    row3     2    29   299



```python
# 3 X 1 데이터프레임

data2  = [[3],[4],[5]]
df2 = pd.DataFrame(data=data2,index=['row1','row2','row3'],columns=['col1'])
print(df2)
```

          col1
    row1     3
    row2     4
    row3     5



```python
result = df.sub(df2)
print(result)
```

          col1  col2  col3
    row1    -2   NaN   NaN
    row2    -2   NaN   NaN
    row3    -2   NaN   NaN



```python
# fill_value: Nan 값을 fill_value값인 0으로 바꾸어서 뺄 수 있게 됨

result = df.sub(df2,fill_value=0)
print(result)
```

          col1  col2   col3
    row1    -2  10.0  100.0
    row2    -2  20.0  200.0
    row3    -2  30.0  300.0


# **곱셈 (mul, rmul)**


```python
# 3 X 3 데이터프레임

data = [[1,10,100],[2,20,200],[3,30,300]]
col = ['col1','col2','col3']
row = ['row1','row2','row3']
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1    10   100
    row2     2    20   200
    row3     3    30   300



```python
result = df.mul(2)
print(result)
```

          col1  col2  col3
    row1     2    20   200
    row2     4    40   400
    row3     6    60   600



```python
result = df*2
print(result)
```

          col1  col2  col3
    row1     2    20   200
    row2     4    40   400
    row3     6    60   600



```python
data2  = [[3],[4],[5]]
df2 = pd.DataFrame(data=data2,index=['row1','row2','row3'],columns=['col1'])
print(df2)
```

          col1
    row1     3
    row2     4
    row3     5



```python
result = df.mul(df2)
print(result)
```

          col1  col2  col3
    row1     3   NaN   NaN
    row2     8   NaN   NaN
    row3    15   NaN   NaN



```python
# fill_value 활용

result = df.mul(df2,fill_value=0)
print(result)
```

          col1  col2  col3
    row1     3   0.0   0.0
    row2     8   0.0   0.0
    row3    15   0.0   0.0


# **나눗셈 (div, rdiv)**


```python
# 3 X 3 데이터프레임

data = [[1,10,100],[2,20,200],[3,30,300]]
col = ['col1','col2','col3']
row = ['row1','row2','row3']
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1    10   100
    row2     2    20   200
    row3     3    30   300



```python
result = df.div(2)
print(result)
```

          col1  col2   col3
    row1   0.5   5.0   50.0
    row2   1.0  10.0  100.0
    row3   1.5  15.0  150.0



```python
result = df/2
print(result)
```

          col1  col2   col3
    row1   0.5   5.0   50.0
    row2   1.0  10.0  100.0
    row3   1.5  15.0  150.0



```python
data2  = [[0],[2],[3]]
df2 = pd.DataFrame(data=data2,index=['row1','row2','row3'],columns=['col1'])
print(df2)
```

          col1
    row1     0
    row2     2
    row3     3



```python
result = df.div(df2)
print(result)
```

          col1  col2  col3
    row1   inf   NaN   NaN
    row2   1.0   NaN   NaN
    row3   1.0   NaN   NaN



```python
# fill_value 활용(나눗셈이므로 1)

result = df.div(df2,fill_value=1)
print(result)
```

          col1  col2   col3
    row1   inf  10.0  100.0
    row2   1.0  20.0  200.0
    row3   1.0  30.0  300.0


# **나머지 (mod, rmod)**


```python
# 3 X 3 데이터프레임

data = [[1,10,100],[2,20,200],[3,30,300]]
col = ['col1','col2','col3']
row = ['row1','row2','row3']
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1    10   100
    row2     2    20   200
    row3     3    30   300



```python
result = df.mod(7)
print(result)
```

          col1  col2  col3
    row1     1     3     2
    row2     2     6     4
    row3     3     2     6



```python
result = df%7
print(result)
```

          col1  col2  col3
    row1     1     3     2
    row2     2     6     4
    row3     3     2     6



```python
data2  = [[2],[3],[5]]
df2 = pd.DataFrame(data=data2,index=['row1','row2','row3'],columns=['col1'])
print(df2)
```

          col1
    row1     2
    row2     3
    row3     5



```python
result = df.mod(df2)
print(result)
```

          col1  col2  col3
    row1     1   NaN   NaN
    row2     2   NaN   NaN
    row3     3   NaN   NaN



```python
# fill_value 활용(나눗셈이므로 1)

result = df.mod(df2,fill_value=1)
print(result)
```

          col1  col2  col3
    row1     1   0.0   0.0
    row2     2   0.0   0.0
    row3     3   0.0   0.0


#**거듭제곱 (pow, rpow)**


```python
data = [[1,2,3],[4,5,6],[7,8,9]]
col = ['col1','col2','col3']
row = ['row1','row2','row3']
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1     2     3
    row2     4     5     6
    row3     7     8     9



```python
result = df.pow(3)
print(result)
```

          col1  col2  col3
    row1     1     8    27
    row2    64   125   216
    row3   343   512   729



```python
result = df**3
print(result)
```

          col1  col2  col3
    row1     1     8    27
    row2    64   125   216
    row3   343   512   729



```python
data2  = [[0],[3],[5]]
df2 = pd.DataFrame(data=data2,index=['row1','row2','row3'],columns=['col1'])
print(df2)
```

          col1
    row1     0
    row2     3
    row3     5



```python
result = df.pow(df2)
print(result)
```

           col1  col2  col3
    row1      1   NaN   NaN
    row2     64   NaN   NaN
    row3  16807   NaN   NaN



```python
# fill_value 활용

result = df.pow(df2,fill_value=0)
print(result)
```

           col1  col2  col3
    row1      1   1.0   1.0
    row2     64   1.0   1.0
    row3  16807   1.0   1.0


## **머신러닝을 위한 선형대수학**

[링크 텍스트](https://brunch.co.kr/@jennyjang93/43)

# **행렬곱 (dot)**
- df.dot(other)
- other : Series, DataFrame, 배열 등

```
       col1 col2                col1 col2                 col1   col2
 row1    A    B     x     row1    a    b     =     row1  Aa+Bc  Ab+Bd
 row2    C    D           row2    c    d           row2  Ca+Dc  Cb+Dd
```


```python
col = ['col1','col2']
row = ['row1','row2']
data1 = [[1,2],[3,4]]
data2 = [[5,6],[7,8]]
df1 = pd.DataFrame(data=data1)
df2 = pd.DataFrame(data=data2)
print(df1)
```

       0  1
    0  1  2
    1  3  4



```python
print(df2)
```

       0  1
    0  5  6
    1  7  8



```python
df3 = df1.dot(df2)
print(df3)
```

        0   1
    0  19  22
    1  43  50


```
   0  1          0  1                0        1           0   1
0  1  2   x   0  5  6   =   0  1*5+2*7  1*6+2*8   =   0  19  22
1  3  4       1  7  8       1  3*5+4*7  3*6+4*8       1  43  50
```

#**반올림 (round)**


```python
# 3 X 3 데이터프레임, 숫자 랜덤

col = ['col1','col2','col3']
row = ['row1','row2','row3']
data = np.random.rand(3,3)*100
df = pd.DataFrame(data=data, index=row, columns=col)
print(df)
```

               col1       col2       col3
    row1  77.173301   2.878248  74.655679
    row2   8.387324  72.528753  38.508465
    row3  53.988678  71.506927  35.925743



```python
# df.round(decimals=0, args, kwargs), decimals: 소수 n번째 자리'까지' 반올림
# 0으로 설정하면 1의 자리까지 반올림함(정수 형태)

print(df.round(0))
```

          col1  col2  col3
    row1  77.0   3.0  75.0
    row2   8.0  73.0  39.0
    row3  54.0  72.0  36.0



```python
# 소수 첫 번째 자리(1)

print(df.round(1))
```

          col1  col2  col3
    row1  77.2   2.9  74.7
    row2   8.4  72.5  38.5
    row3  54.0  71.5  35.9



```python
# 소수 두 번째 자리(2)

print(df.round(2))
```

           col1   col2   col3
    row1  77.17   2.88  74.66
    row2   8.39  72.53  38.51
    row3  53.99  71.51  35.93



```python
# 음수인 경우 10의 n승까지 반올림(10의 1승)

print(df.round(-1))
```

          col1  col2  col3
    row1  80.0   0.0  70.0
    row2  10.0  70.0  40.0
    row3  50.0  70.0  40.0


#**합계(sum)**
- axis: {0 : 행 / 1 : 열} 더할 레이블을 선택
- skipna: {True or False} NaN이 존재할 경우 무시할 지 여부. 기본값은 True.
- level: Multi Index일 경우 레벨을 설정
- numeric_only: 숫자 데이터만 사용할 지 여부
- min_count: 계산에 필요한 숫자의 최소 개수


```python
# 3 X 3 데이터프레임, NaN 포함(업데이트 되면서 np.NaN에서 np.nan으로 내장함수가 바뀜)

col = ['col1','col2','col3']
row = ['row1','row2','row3']
data = [[1,2,3],[4,5,6],[7,np.nan,9]]
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1   2.0     3
    row2     4   5.0     6
    row3     7   NaN     9



```python
# 0은 열의 요소들의 합(NaN값을 제외하고 더함)

print(df.sum(axis=0))
```

    col1    12.0
    col2     7.0
    col3    18.0
    dtype: float64



```python
# 1은 행의 요소들의 합(NaN값을 제외하고 더함)

print(df.sum(axis=1))
```

    row1     6.0
    row2    15.0
    row3    16.0
    dtype: float64



```python
# skipna=False일 경우 더하는 요소들 중 NaN이 포함되면 NaN을 반환

print(df.sum(axis=0,skipna=False))
```

    col1    12.0
    col2     NaN
    col3    18.0
    dtype: float64



```python
# min_count는 계산에 필요한 숫자의 최소 갯수
# min_count=3로 하면 NaN을 포함하는 행의 경우 숫자가 2개라
# 3개를 충족하지 못하여 skipna=True임에도 NaN을 출력

print(df.sum(axis=1,min_count=3))
```

    row1     6.0
    row2    15.0
    row3     NaN
    dtype: float64


#**곱 (prod, product)**


```python
# 3 X 3 데이터프레임, NaN 포함(업데이트 되면서 np.NaN에서 np.nan으로 내장함수가 바뀜)

col = ['col1','col2','col3']
row = ['row1','row2','row3']
data = [[1,2,3],[4,5,6],[7,np.nan,9]]
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2  col3
    row1     1   2.0     3
    row2     4   5.0     6
    row3     7   NaN     9



```python
# 0은 열의 요소들의 곱(NaN값을 제외하고 곱함)

print(df.prod(axis=0))
```

    col1     28.0
    col2     10.0
    col3    162.0
    dtype: float64



```python
# 1은 행의 요소들의 곱(NaN값을 제외하고 곱함)

print(df.prod(axis=1))
```

    row1      6.0
    row2    120.0
    row3     63.0
    dtype: float64



```python
# skipna=False일 경우 곱하는 요소들 중 NaN이 포함되면 NaN을 반환

print(df.prod(axis=0, skipna=False))
```

    col1     28.0
    col2      NaN
    col3    162.0
    dtype: float64



```python
# min_count는 계산에 필요한 숫자의 최소 갯수
# min_count=3로 하면 NaN을 포함하는 행의 경우 숫자가 2개라
# 3개를 충족하지 못하여 skipna=True임에도 NaN을 출력

print(df.prod(axis=1,min_count=3))
```

    row1      6.0
    row2    120.0
    row3      NaN
    dtype: float64


#**절대값 (abs)**
- 숫자일 때: 절댓값 반환
- 복소수일 때: 복소수의 크기가 반환
- 복소수: 실수(real number)와 허수(imaginary number)를 포함하는 수
- a+bi꼴로 나타내는 수
- a+bj인 경우 복소수는 루트 (a제곱+b제곱)


```python
# 3 X 3 데이터프레임, 복소수와 NaN 포함(업데이트 되면서 np.NaN에서 np.nan으로 내장함수가 바뀜)

col = ['col1','col2','col3']
row = ['row1','row2','row3']
data = [[-1,2,-3.5],[4,-5.5,3+4j],[7,np.nan,9]]
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

          col1  col2      col3
    row1    -1   2.0 -3.5+0.0j
    row2     4  -5.5  3.0+4.0j
    row3     7   NaN  9.0+0.0j



```python
# 일반 숫자는 절댓값, 복소수는 크기가 출력

print(df.abs( ))
```

          col1  col2  col3
    row1     1   2.0   3.5
    row2     4   5.5   5.0
    row3     7   NaN   9.0


#**전치(transpose, T)**
- (n,m)짜리 DataFrame이라면 (0,0) 부터 (n,m)을 연결하는 대각선을 중심으로 뒤집음


```python
# 4 X 3 데이터프레임

col = ['col1','col2','col3']
row = ['row1','row2','row3','row4']
data = [['A',1,2],['B',3,4],['C',5,6],['D',7,8]]
df = pd.DataFrame(data=data,index=row,columns=col)
print(df)
```

         col1  col2  col3
    row1    A     1     2
    row2    B     3     4
    row3    C     5     6
    row4    D     7     8



```python
# 오른쪽 대각선을 기준으로 뒤집힌 것을 볼 수 있음

print(df.transpose())
```

         row1 row2 row3 row4
    col1    A    B    C    D
    col2    1    3    5    7
    col3    2    4    6    8


#**순위 (rank)**
- 축에 대해서 순위를 매기는 메서드, 동일 순위일 경우 평균을 반환
- axis: {0 : index / 1 : columns} 순위를 매길 레이블
- method: {'average' / 'min' / 'max' / 'first' / 'dense'} 동순위일때 처리 방법
`average는 평균, min은 낮은 순위, max는 높은 순위, first는 나타나는 순서대로 dense의 경우는 min과 같지만 그룹간 순위는 항상 1씩 증가`
- numeric_only: {True / False} 숫자만 순위를 매길지 여부
- na_option: {'keep' / 'top' / 'bottom'} NaN값의 처리 방법
`keep의 경우 NaN순위 할당, top의 경우 낮은 순위 할당, bottom의 경우 높은 순위 할당`
- ascending: {True / False} 오름차순으로 할지의 여부
- pct: {True / False} 순위를 백분위수형식으로 할지 여부


```python
# pd.NA 포함, 9 X 1 데이터프레임

data = [[5],[5],[pd.NA],[3],[-3.1],[5],[0.4],[6.7],[3]]
row = ['A★','B★','C','D☆','E','F★','G','H','I☆']
df = pd.DataFrame(data=data, index=row, columns=['Value'])
print(df)
```

       Value
    A★     5
    B★     5
    C   <NA>
    D☆     3
    E   -3.1
    F★     5
    G    0.4
    H    6.7
    I☆     3


- average: D와 I의 경우 각각 3등 4등이기때문에 3.5 출력
- min: A, B, F의 경우 각각 5등 6등 7등으로 가장 낮은등수인 5 출력
- max: A, B, F의 경우 각각 5등 6등 7등으로 가장 높등수인 7 출력
- first: 동점일경우 위에서부터 매김 D와 I 각각 3등 4등
- dense: min처럼 동작하지만 등수가 순차적으로 증가


```python
df['average']=df['Value'].rank(method='average')
df['min']=df['Value'].rank(method='min')
df['max']=df['Value'].rank(method='max')
df['first']=df['Value'].rank(method='first')
df['dense']=df['Value'].rank(method='dense')
print(df)
```

       Value  average  min  max  first  dense
    A★     5      6.0  5.0  7.0    5.0    4.0
    B★     5      6.0  5.0  7.0    6.0    4.0
    C   <NA>      NaN  NaN  NaN    NaN    NaN
    D☆     3      3.5  3.0  4.0    3.0    3.0
    E   -3.1      1.0  1.0  1.0    1.0    1.0
    F★     5      6.0  5.0  7.0    7.0    4.0
    G    0.4      2.0  2.0  2.0    2.0    2.0
    H    6.7      8.0  8.0  8.0    8.0    5.0
    I☆     3      3.5  3.0  4.0    4.0    3.0


- na_option에 따라 Na가 포함된경우 순위가 어떻게 매겨지는지 확인할 수 있음
- 추가로 pct의 경우도 추가


```
- keep : Na요소에 NaN을 부여하여 그대로 둠.
- top : Na에게 가장 높은 순위를 부여. 1등이 된것을 볼 수 있음
- bottom : Na에게 가장 높은 순위를 부여. 9등이 된것을 볼 수 있음.
- pct : True일 경우 백분위수로 표시.
```

#**차이[이산] (diff)**
- axis: 비교할 축을 지정. axis=0인 경우 행끼리 비교하고 axis=1인 경우 열끼리 비교
- periods: 비교할 간격을 지정. 기본은 +1로 바로 이전 값과 비교


```python
# 8 X 3 데이터프레임

a = [1,2,3,4,5,6,7,8]
b = [1,2,4,8,16,32,64,128]
c = [8,7,6,5,4,3,2,1]
data = {"col1":a,"col2":b,"col3":c}
df = pd.DataFrame(data)
print(df)
```

       col1  col2  col3
    0     1     1     8
    1     2     2     7
    2     3     4     6
    3     4     8     5
    4     5    16     4
    5     6    32     3
    6     7    64     2
    7     8   128     1



```python
# axis = 0, 행 빼기 바로 전의 행, 비교할 값이 없는 0행은 NaN출력

print(df.diff(axis=0))
```

       col1  col2  col3
    0   NaN   NaN   NaN
    1   1.0   1.0  -1.0
    2   1.0   2.0  -1.0
    3   1.0   4.0  -1.0
    4   1.0   8.0  -1.0
    5   1.0  16.0  -1.0
    6   1.0  32.0  -1.0
    7   1.0  64.0  -1.0



```python
# axis = 1, 열 빼기 바로 전의 열, 비교할 값이 없는 0열은 NaN출력

print(df.diff(axis=1))
```

       col1  col2  col3
    0   NaN     0     7
    1   NaN     0     5
    2   NaN     1     2
    3   NaN     4    -3
    4   NaN    11   -12
    5   NaN    26   -29
    6   NaN    57   -62
    7   NaN   120  -127



```python
# periods 기본값은 +1이고 +1인 경우 바로 이전 값과의 차를 출력
# +3일 경우 3칸 "이전", -3인 경우 3칸 "이후"의 값과 비교

print(df.diff(periods=3))
```

       col1   col2  col3
    0   NaN    NaN   NaN
    1   NaN    NaN   NaN
    2   NaN    NaN   NaN
    3   3.0    7.0  -3.0
    4   3.0   14.0  -3.0
    5   3.0   28.0  -3.0
    6   3.0   56.0  -3.0
    7   3.0  112.0  -3.0



```python
print(df.diff(periods=-3))
```

       col1   col2  col3
    0  -3.0   -7.0   3.0
    1  -3.0  -14.0   3.0
    2  -3.0  -28.0   3.0
    3  -3.0  -56.0   3.0
    4  -3.0 -112.0   3.0
    5   NaN    NaN   NaN
    6   NaN    NaN   NaN
    7   NaN    NaN   NaN


#**차이[백분률] (pct_change)**
- periods: 비교할 간격을 지정합니다. 기본은 +1로 바로 이전 값과 비교
- fill_method: {ffill : 앞의 값으로 채움 / bfill : 뒤의 값으로 채움} 결측치를 대체할 값
- limit: 결측값을 몇개나 대체할지 정할 수 있음
- freq: 시계열 API에서 사용할 증분을 지정. (예: 'M' 또는 BDay( ))


```python
# 6 X 3 데이터프레임

a = [1,1,4,4,1,1]
b = [1,2,4,8,16,32]
c = [1,np.nan,np.nan,np.nan,16,64]
data = {"col1":a,"col2":b,"col3":c}
df = pd.DataFrame(data)
print(df)
```

       col1  col2  col3
    0     1     1   1.0
    1     1     2   NaN
    2     4     4   NaN
    3     4     8   NaN
    4     1    16  16.0
    5     1    32  64.0



```python
# pct_change는 (다음행 - 현재행)/현재행

print(df.pct_change())
```

       col1  col2  col3
    0   NaN   NaN   NaN
    1  0.00   1.0   0.0
    2  3.00   1.0   0.0
    3  0.00   1.0   0.0
    4 -0.75   1.0  15.0
    5  0.00   1.0   3.0


    /tmp/ipython-input-1643334816.py:3: FutureWarning: The default fill_method='pad' in DataFrame.pct_change is deprecated and will be removed in a future version. Either fill in any non-leading NA values prior to calling pct_change or specify 'fill_method=None' to not fill NA values.
      print(df.pct_change())



```python
# periods는 계산 간격을 나타냄(+가 이전, -가 이후)

print(df.pct_change(periods=2))
```

       col1  col2  col3
    0   NaN   NaN   NaN
    1   NaN   NaN   NaN
    2  3.00   3.0   0.0
    3  3.00   3.0   0.0
    4 -0.75   3.0  15.0
    5 -0.75   3.0  63.0


    /tmp/ipython-input-3576848795.py:3: FutureWarning: The default fill_method='pad' in DataFrame.pct_change is deprecated and will be removed in a future version. Either fill in any non-leading NA values prior to calling pct_change or specify 'fill_method=None' to not fill NA values.
      print(df.pct_change(periods=2))



```python
# periods=-1로 (현재행 - 다음행)/다음행을 계산할 수 있음

print(df.pct_change(periods=-1))
```

       col1  col2    col3
    0  0.00  -0.5  0.0000
    1 -0.75  -0.5  0.0000
    2  0.00  -0.5  0.0000
    3  3.00  -0.5 -0.9375
    4  0.00  -0.5 -0.7500
    5   NaN   NaN     NaN


    /tmp/ipython-input-10524734.py:3: FutureWarning: The default fill_method='pad' in DataFrame.pct_change is deprecated and will be removed in a future version. Either fill in any non-leading NA values prior to calling pct_change or specify 'fill_method=None' to not fill NA values.
      print(df.pct_change(periods=-1))



```python
# fill_method인수는 결측치를 대체할 값을 지정할 수 있음
# fill_method='ffill'인 경우는 기본값으로 바로 윗값으로 결측치를 대체
# fill_method='bfill'인 경우는 바로 아랫값으로 결측치를 대체

print(df.pct_change(fill_method='bfill'))
```

       col1  col2  col3
    0   NaN   NaN   NaN
    1  0.00   1.0  15.0
    2  3.00   1.0   0.0
    3  0.00   1.0   0.0
    4 -0.75   1.0   0.0
    5  0.00   1.0   3.0


    /tmp/ipython-input-3523146207.py:5: FutureWarning: The 'fill_method' keyword being not None and the 'limit' keyword in DataFrame.pct_change are deprecated and will be removed in a future version. Either fill in any non-leading NA values prior to calling pct_change or specify 'fill_method=None' to not fill NA values.
      print(df.pct_change(fill_method='bfill'))



```python
# limit로 결측치를 얼마나 대체할 지 지정

print(df.pct_change(limit=2))
```

       col1  col2  col3
    0   NaN   NaN   NaN
    1  0.00   1.0   0.0
    2  3.00   1.0   0.0
    3  0.00   1.0   NaN
    4 -0.75   1.0   NaN
    5  0.00   1.0   3.0


    /tmp/ipython-input-1588249521.py:3: FutureWarning: The 'fill_method' keyword being not None and the 'limit' keyword in DataFrame.pct_change are deprecated and will be removed in a future version. Either fill in any non-leading NA values prior to calling pct_change or specify 'fill_method=None' to not fill NA values.
      print(df.pct_change(limit=2))


#**누적 계산 (expending)**

- min_periods : 연산을 수행할 요소의 최소 갯수. 이보다 작으면 NaN을 출력
- axis : 누적 연산을 수행할 축을 지정.
- method : {single / table} 연산을 한 줄씩 수행할지 아니면 전체 테이블에 대해서 롤링을 수행할지 여부
- 기본값은 'singl'로 한 줄씩 연산을 수행. 'table'을 사용하기 위해서는 numba 라이브러리 필요, engine=numba로 설정


```python
import numba
```


```python
# 4 X 2 데이터프레임

data = {'col1':[1,2,3,4],'col2':[3,7,5,6]}
idx = ['row1','row2','row3','row4']
df = pd.DataFrame(data = data, index = idx)
print(df)
```

          col1  col2
    row1     1     3
    row2     2     7
    row3     3     5
    row4     4     6



```python
# 열마다 누적으로 sum을 함

print(df.expanding().sum())
```

          col1  col2
    row1   1.0   3.0
    row2   3.0  10.0
    row3   6.0  15.0
    row4  10.0  21.0



```python
# min_period로 설정한 갯수만큼 충족이 되지 않으면 연산을 하지 않고 NaN을 반환

print(df.expanding(min_periods=4).sum())
```

          col1  col2
    row1   NaN   NaN
    row2   NaN   NaN
    row3   NaN   NaN
    row4  10.0  21.0



```python
# axis=1로 지정하면 열 기준으로 누적값의 계산이 수행

print(df.expanding(axis=1).sum())
```

          col1  col2
    row1   1.0   4.0
    row2   2.0   9.0
    row3   3.0   8.0
    row4   4.0  10.0


    /tmp/ipython-input-410284846.py:1: FutureWarning: Support for axis=1 in DataFrame.expanding is deprecated and will be removed in a future version. Use obj.T.expanding(...) instead
      print(df.expanding(axis=1).sum())



```python
# method='table'로 입력할 경우 numba 라이브러리를 이용해 연산을 테이블단위로 롤링

print(df.expanding(method='table').sum(engine='numba'))
```

          col1  col2
    row1   1.0   3.0
    row2   3.0  10.0
    row3   6.0  15.0
    row4  10.0  21.0


#**기간이동 계산 (rolling)**

- window: 계산할 창(window)의 크기. 열 기준으로 계산할 경우 행의 수.
- min_periods: 계산할 최소 크기(기간) 입니다. window 안의 값의 수가 min_periods의 값보다 작을경우 NaN을 출력 기본은 window 크기와 동일.
- center: {True / False} 레이블을 window의 중간에 둘지 여부. 기본값은 False로 레이블이 창 우측에 위치.
- win_type: {'triang' / 'gaussian' / ...} 등 가중치를 넣어 계산할 경우 계산 방식.
- on: 시계열 인덱스나, 시계열과 유사한 열이 있을 경우 이 열을 기준으로 rolling을 수행할 수 있음
- axis : 계산의 기준이 될 축
- closed : {'left' / 'right' / 'both' / 'neither'} window가 닫히는 방향
- method :{'single'} numba 를 이용하여 테이블 계산을 진행하여 속도를 높힐지 여부. 현재 'single'만 사용가능


```python
# 6 X 2 데이터프레임

period = pd.period_range(start='2022-01-13 00:00:00',end='2022-01-13 02:30:00',freq='30T')
data = {'col1':[1,2,3,4,5,6],'col2':period}
idx = ['row1','row2','row3','row4','row5','row6']
df = pd.DataFrame(data= data, index = idx)
print(df)
```

          col1              col2
    row1     1  2022-01-13 00:00
    row2     2  2022-01-13 00:30
    row3     3  2022-01-13 01:00
    row4     4  2022-01-13 01:30
    row5     5  2022-01-13 02:00
    row6     6  2022-01-13 02:30


    /tmp/ipython-input-4224765576.py:3: FutureWarning: 'T' is deprecated and will be removed in a future version, please use 'min' instead.
      period = pd.period_range(start='2022-01-13 00:00:00',end='2022-01-13 02:30:00',freq='30T')



```python
# window 크기를 지정해주면, 현재 행 이전으로 window 크기만큼의 계산을 수행

print(df['col1'].rolling(window=3).sum())
```

    row1     NaN
    row2     NaN
    row3     6.0
    row4     9.0
    row5    12.0
    row6    15.0
    Name: col1, dtype: float64


- closed는 계산의 닫는 위치를 지정
- 만약 6행을 기준으로 window=3을 계산한다고 하면 아래와 같은 범위로 window경계가 지정

```
left : 3 ≤ x < 6
right : 3 < x ≤ 6
both : 3 ≤ x ≤ 6
neither : 3 < x < 6
```


```python
# closed='left'인 경우

print(df['col1'].rolling(window=3, closed='left').sum())
```

    row1     NaN
    row2     NaN
    row3     NaN
    row4     6.0
    row5     9.0
    row6    12.0
    Name: col1, dtype: float64



```python
# closed='right'인 경우

print(df['col1'].rolling(window=3, closed='right').sum())
```

    row1     NaN
    row2     NaN
    row3     6.0
    row4     9.0
    row5    12.0
    row6    15.0
    Name: col1, dtype: float64



```python
# closed='both'인 경우

print(df['col1'].rolling(window=3, closed='both').sum())
```

    row1     NaN
    row2     NaN
    row3     6.0
    row4    10.0
    row5    14.0
    row6    18.0
    Name: col1, dtype: float64



```python
# closed='neither'인 경우
# min_period보다 window 크기가 작으므로 min_period를 지정해주어야 함

print(df['col1'].rolling(window=3, closed='neither').sum())
```

    row1   NaN
    row2   NaN
    row3   NaN
    row4   NaN
    row5   NaN
    row6   NaN
    Name: col1, dtype: float64


##**center 인수**


```python
# center=True인 경우 레이블이 window의 중앙에 위치

print(df['col1'].rolling(window=3, center=True).sum())
```

    row1     NaN
    row2     6.0
    row3     9.0
    row4    12.0
    row5    15.0
    row6     NaN
    Name: col1, dtype: float64



```python
# win_type을 지정할 경우 가중치를 주며 계산 가능

print(df['col1'].rolling(window=3, win_type='triang').sum())  # 삼각함수로 가중치 부여
```

    row1     NaN
    row2     NaN
    row3     4.0
    row4     6.0
    row5     8.0
    row6    10.0
    Name: col1, dtype: float64



```python
print(df['col1'].rolling(window=3, win_type='gaussian').sum(std=3))   # 가우시안 분포로 가중치 부여
```

    row1          NaN
    row2          NaN
    row3     5.783838
    row4     8.675757
    row5    11.567676
    row6    14.459595
    Name: col1, dtype: float64



```python
# on 인수 사용
# on='col2'를 이용하여 col2열의 시계열 인덱스를 기준으로 rolling의 수행이 가능

print(df.rolling(window='60T',on='col2').sum())
```

          col1              col2
    row1   1.0  2022-01-13 00:00
    row2   3.0  2022-01-13 00:30
    row3   5.0  2022-01-13 01:00
    row4   7.0  2022-01-13 01:30
    row5   9.0  2022-01-13 02:00
    row6  11.0  2022-01-13 02:30


    /tmp/ipython-input-1319899622.py:4: FutureWarning: 'T' is deprecated and will be removed in a future version, please use 'min' instead.
      print(df.rolling(window='60T',on='col2').sum())

