--- 
layout: single
published: true
title: "26.01.28. 데일리미션: 데이터 시각화 실습(titanic)"
---


# 객체병합(merge), 인덱스기준 병합 (join), 함수 이용 열/행 단위 결합 (combine), 정렬 후 추출, 값 기준 / 인덱스 기준 정렬 



```python
from google.colab import drive
drive.mount('/content/drive')
```


```python
!jupyter nbconvert --to markdown "/content/drive/MyDrive/구름 생성AI/구름exp/26.01.28 데일리미션.ipynb"
```

# **데이터 시각화: 타이타닉 데이터**


```python
# 라이브러리 설치

import pandas as pd
import numpy as np
```

# **Kaggle Dataset**
- This is the original data from Titanic competition plus some changes that I applied to it to be better suited for binary logistic regression:

- Merged the train and test data.

- Removed the 'ticket' and 'cabin' attributes.

- Moved the 'Survived' attribute to the last column.

- Added extra zero columns for categorical inputs to be better suited for One-Hot-Encoding.

- Substituted the values of 'Sex' and 'Embarked' attributes with binary and categorical values respectively.

- Filled the missing values in 'Age' and 'Fare' attributes with the median of the data.


```python
# 1. train.csv 파일 읽기
df = pd.read_csv('train.csv')

print(df.head(5))
```

       Passengerid   Age     Fare  Sex  sibsp  zero  zero.1  zero.2  zero.3  \
    0            1  22.0   7.2500    0      1     0       0       0       0   
    1            2  38.0  71.2833    1      1     0       0       0       0   
    2            3  26.0   7.9250    1      0     0       0       0       0   
    3            4  35.0  53.1000    1      1     0       0       0       0   
    4            5  35.0   8.0500    0      0     0       0       0       0   
    
       zero.4  ...  zero.12  zero.13  zero.14  Pclass  zero.15  zero.16  Embarked  \
    0       0  ...        0        0        0       3        0        0       2.0   
    1       0  ...        0        0        0       1        0        0       0.0   
    2       0  ...        0        0        0       3        0        0       2.0   
    3       0  ...        0        0        0       1        0        0       2.0   
    4       0  ...        0        0        0       3        0        0       2.0   
    
       zero.17  zero.18  2urvived  
    0        0        0         0  
    1        0        0         1  
    2        0        0         1  
    3        0        0         1  
    4        0        0         0  
    
    [5 rows x 28 columns]



```python
# 데이터 나누기
# df1: ID, 나이, 성별
# df2: ID, 객실등급, 요금, 생존여부
df1 = df[['Passengerid', 'Age', 'Sex']].iloc[:10].copy()
df2 = df[['Passengerid', 'Pclass', 'Fare', '2urvived']].iloc[:10].copy()
```

# **1. 객체병합(merge)에 필요한 메서드 활용하기**


```python
# 1. 객체병합(merge) 활용하기
# Passengerid를 기준으로 두 가지 데이터를 합치기
# on 인수를 사용하여 기준 열 정하기
df_merge = df1.merge(df2, on='Passengerid', how='inner')
print("================== 1. 객체병합(merge)================== \n", df_merge.head(5))
```

    ================== 1. 객체병합(merge)================== 
        Passengerid   Age  Sex  Pclass     Fare  2urvived
    0            1  22.0    0       3   7.2500         0
    1            2  38.0    1       1  71.2833         1
    2            3  26.0    1       3   7.9250         1
    3            4  35.0    1       1  53.1000         1
    4            5  35.0    0       3   8.0500         0


# **2. 인덱스기준 병합 (join) 메서드 활용하기**


```python
# 2. 인덱스기준 병합 (join) 활용하기
# set_index 인수를 사용해서 열을 인덱스로 변경한 후 join 사용


df_left = df[['Passengerid', 'Age', 'Sex']].iloc[:5].set_index('Passengerid')
df_right = df[['Passengerid', 'Age', 'Fare']].iloc[:5].set_index('Passengerid')


print(df_left)
print("\n")
print(df_right)
```

                  Age  Sex
    Passengerid           
    1            22.0    0
    2            38.0    1
    3            26.0    1
    4            35.0    1
    5            35.0    0
    
    
                  Age     Fare
    Passengerid               
    1            22.0   7.2500
    2            38.0  71.2833
    3            26.0   7.9250
    4            35.0  53.1000
    5            35.0   8.0500



```python
# lsuffix / rsuffix 인수를 통해 중복 열 구분

df_join = df_left.join(df_right, lsuffix='_left', rsuffix='_right')
```


```python
print("================== 2. 인덱스기준 병합 (join)================== \n", df_join.head(5))
```

    ================== 2. 인덱스기준 병합 (join)================== 
                  Age_left  Sex  Age_right     Fare
    Passengerid                                   
    1                22.0    0       22.0   7.2500
    2                38.0    1       38.0  71.2833
    3                26.0    1       26.0   7.9250
    4                35.0    1       35.0  53.1000
    5                35.0    0       35.0   8.0500


# **3. 함수 이용 열/행 단위 결합 (combine, combine_first) 메서드 활용**


```python
# 3. 함수를 이용한 결합 (combine, combine_first) 활용하기
# self의 NaN값을 other의 값으로 바꾸기

df_age = df1[['Age']].copy()
df_age.iloc[0:2, 0] = np.nan  # 실습을 위해 NaN 값을 넣기

# combine_first 활용하기
filled = df_age.combine_first(df1[['Age']])

# combine 활용하기 np.maximum으로 더 큰 값 비교
# df1의 나이와 filled를 비교하여 큰 값 선택
df_combine = df1[['Age']].combine(filled, np.maximum)
```


```python
print("============= 3. 함수를 이용한 결합 (combine, combine_first)============= \n", df_combine.head(5))
```

    ============= 3. 함수를 이용한 결합 (combine, combine_first)============= 
         Age
    0  22.0
    1  38.0
    2  26.0
    3  35.0
    4  35.0


# **4. 정렬 후 추출 메서드 활용하기**


```python
# 4. 정렬 후 추출 (nlargest) 메서드
# n개 행 출력. 요금(Fare)이 가장 높은 5명 출력하기
top_5 = df.nlargest(n = 5, columns='Fare')
```


```python
print("======== 4. 정렬 후 추출 메서드 활용(top5) ======== \n", top_5[['Passengerid', 'Fare']])
```

    ======== 4. 정렬 후 추출 메서드 활용(top5) ======== 
           Passengerid      Fare
    258           259  512.3292
    679           680  512.3292
    737           738  512.3292
    1234         1235  512.3292
    27             28  263.0000


# **5. 값 기준 / 인덱스 기준 정렬 메서드 활용하기**


```python
# 5. 값 기준 / 인덱스 기준 정렬 메서드
# by를 기준으로 정렬. 나이(Age) 내림차순, 결측값을 last로

values = df.sort_values(by='Age', ascending=False, na_position='last')

print("======== 5-1. 값 기준 정렬 ======== \n", values[['Passengerid', 'Age']]. head(5), "\n\n", values[['Passengerid', 'Age']]. tail(5))
```

    ======== 5-1. 값 기준 정렬 ======== 
          Passengerid   Age
    630          631  80.0
    987          988  76.0
    851          852  74.0
    96            97  71.0
    493          494  71.0 
    
           Passengerid   Age
    644           645  0.75
    755           756  0.67
    803           804  0.42
    1092         1093  0.33
    1245         1246  0.17



```python
# 인덱스 정렬 (sort_index)

index = df.sort_index(ascending=False)

print("======== 5-2. 인덱스 기준 정렬 ======== \n", index[['Passengerid', 'Age']]. head(5), "\n\n", index[['Passengerid', 'Age']]. tail(5))
```

    ======== 5-2. 인덱스 기준 정렬 ======== 
           Passengerid   Age
    1308         1309  28.0
    1307         1308  28.0
    1306         1307  38.5
    1305         1306  39.0
    1304         1305  28.0 
    
        Passengerid   Age
    4            5  35.0
    3            4  35.0
    2            3  26.0
    1            2  38.0
    0            1  22.0

