---
layout: single
title:  "파이썬 객체지향 정리"
---

# 함수, 클래스와 인스턴스, 변수와 메서드, 상속



```python
from google.colab import drive
drive.mount('/content/drive')
```

    Mounted at /content/drive



```python
!jupyter nbconvert --to markdown "/content/drive/MyDrive/구름 생성AI/구름exp/깃허브 기술블로그/exp 과제: 파이썬 객체지향 .ipynb"
```

    [NbConvertApp] WARNING | Unrecognized alias: 'to', it will have no effect.
    Traceback (most recent call last):
      File "/usr/local/bin/jupyter-nbconvert", line 10, in <module>
        sys.exit(main())
                 ^^^^^^
      File "/usr/local/lib/python3.12/dist-packages/jupyter_core/application.py", line 284, in launch_instance
        super().launch_instance(argv=argv, **kwargs)
      File "/usr/local/lib/python3.12/dist-packages/traitlets/config/application.py", line 992, in launch_instance
        app.start()
      File "/usr/local/lib/python3.12/dist-packages/nbconvert/nbconvertapp.py", line 420, in start
        self.convert_notebooks()
      File "/usr/local/lib/python3.12/dist-packages/nbconvert/nbconvertapp.py", line 582, in convert_notebooks
        raise ValueError(msg)
    ValueError: Please specify an output format with '--to <format>'.
    The following formats are available: ['asciidoc', 'custom', 'html', 'latex', 'markdown', 'notebook', 'pdf', 'python', 'qtpdf', 'qtpng', 'rst', 'script', 'slides', 'webpdf']


# **함수**
* 단어 그대로 입력에 따른 출력을 정의
* 출처: https://wikidocs.net/24

### **파이썬 함수의 구조**


```
def 함수_이름(매개변수):
    수행할_문장1
    수행할_문장2
```

* 함수를 정의한 후 if, while, for 문 등처럼 함수에서 수행할 문장을 입력




```python
# 더하는 함수 정의

def add(a, b):
    return a + b
```


```python
a = 3
b = 4
```


```python
add(a,b)
```




    7



* 일반적인 함수 형태
  
```
def 함수_이름(매개변수):
    수행할_문장
    ...
    return 반환값

```


```
반환값을_받을_변수 = 함수_이름(입력_인수1, 입력_인수2, ...)
```

### **입력값이 없는 함수**

```
반환값을_받을_변수 = 함수_이름()
```


```
def say():
  return 'Hi'
```


```python
a = say()                             # 함수를 쓰기 위해서는 괄호 안에 아무것도 넣지 말아야 함
```


```python
a
```




    'Hi'



### **반환값이 없는 함수**

```
함수_이름(입력_인수1, 입력_인수2, ...)
```


```python
def add(a, b):
  print("%d, %d의 합은 %d입니다." % (a, b, a+b))
```


```python
add(3, 4)
```

    3, 4의 합은 7입니다.


* 위의 코드처럼 print를 할 수는 있지만 return으로 받을 반환값이 없음


```python
a = add(3, 4)
```

    3, 4의 합은 7입니다.



```python
print(a)                            # a에 할당된 값이 없음을 확인 가능
```

    None


### **반환값이 없는 함수**

```
함수_이름()
```


```python
def say():
  print('Hi')
```


```python
say()                                         # 함수 이름을 냅다 부르는 것밖에 사용법이 없음
```

    Hi


### **매개변수를 지정하여 호출**


```python
def sub(a, b):
  return a - b
```

* 매개변수 지정해보기


```python
result = sub(a = 7, b = 3)                    # a에 7, b에 3 전달

print(result)
```

    4



```python
# b = 5, a = 3 이런 식으로 원래 함수 순서를 신경 쓸 필요없음

result = sub(b = 5, a = 3)                        # b에 5, a에 3 전달
print(result)
```

    -2


# **입력값의 갯수를 모를 때: 가변 매개변수 args**
* args는 관례적인 것

```
def 함수_이름(*매개변수):
    수행할_문장
    ...
```


```python
# 매개변수 이름(args) 앞에 *을 붙여주면 입력값을 모두 모아 tuple로 만들어줌
def add_many(*args):      # 입력값을 받아 순서대로 묶은 tuple이 됨
  result = 0
  for i in args:
    result = result + i   # *args에 입력받은 모든 값을 더함
  return result
```


```python
result = add_many(1, 2, 3)
```


```python
print(result)
```

    6



```python
result2 = add_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```


```python
print(result2)
```

    55



```python
# choice 매개변수를 같이 사용
def add_mul(choice, *args):
  if choice == "add":             # 매개변수 choice에 "add"를 입력받았을 때
    result = 0
    for i in args:                # i씩 더하는 반복문(입력되는 모든 값 더하기)
      result = result + i

  elif choice == "mul":           # 매개변수 choice에 "mul"을 입력받았을 때
    result = 1
    for i in args:                # i씩 곱하는 반복문(입력되는 모든 값 곱하기)
      result = result * i
  return result
```


```python
result = add_mul('add', 1, 2, 3, 4, 5)
```


```python
print(result)
```

    15



```python
result = add_mul('mul', 1, 2, 3, 4, 5)
```


```python
print(result)
```

    120


# **키워드 매개변수, kwargs**
* 함수 호출 시 키워드 = 값 형태로 전달하는 매개변수를 받을 때 사용
* 매개변수 앞에 별 2개(**)를 붙임
*  kwargs도 마찬가지로 관례적인 것


```python
def print_kwargs(**kwargs):
  print(kwargs)
```


```python
# 입력받은 키워드 매개변수들을 딕셔너리 형태로 출력하는 함수 print_kwargs
print_kwargs(a = 1)
```

    {'a': 1}



```python
print_kwargs(name = 'jiin', age = 26)
```

    {'name': 'jiin', 'age': 26}



```python
def print_test(**test):
  print(test)
```


```python
print_test(a = 1)
```

    {'a': 1}


* **kwargs처럼 매개변수 이름 앞에 **을 붙이면 매개변수(kwargs)는 딕셔너리가 되고 모든 키워드=값 형태의 입력값이 그 딕셔너리에 저장된다.


```python
def create_profile(**info):
  print("=== 프로필 정보 ===")
  for key, value in info.items():
    print(f"{key}: {value}")
```


```python
create_profile(이름 = "박지인", 나이 = 26, 직업 = "학생")
```

    === 프로필 정보 ===
    이름: 박지인
    나이: 26
    직업: 학생


* 일반 매개변수, 가변 매개변수(*args), 키워드 매개변수(**kwargs)를 모두 함께 사용할 수도 있지만 순서가 중요


```
일반 매개변수, 가변 매개변수(*args), 키워드 매개변수(**kwargs)
```




```python
def mixed_function(name, *args, **kwargs):
  print(f"이름: {name}")
  print(f"추가 인수들: {args}")
  print(f"키워드 인수들: {kwargs}")
```


```python
mixed_function("박지인", 1, 2, 3, age = 26, city='서울')
```

    이름: 박지인
    추가 인수들: (1, 2, 3)
    키워드 인수들: {'age': 26, 'city': '서울'}


# **함수의 반환값은 하나여야 함**


```python
def add_and_mul(a,b):
  return a+b, a*b
```


```python
# 반환값은 a+b와 a*b인데, 반환값을 받아들이는 변수는 result 하나만 쓰임
result = add_and_mul(3,4)
```


```python
# 함수의 반환값은 언제나 1개이기에 tuple값 하나인 (a+b, a*b)로 리턴
result
```




    (7, 12)




```python
# result1, result2에 tuple 하나를 나눠서 받기
result1, result2 = add_and_mul(3, 4)
```


```python
result1
```




    7




```python
result2
```




    12




```python
# return문을 2번 사용한다면?
def add_and_mul(a,b):
  return a+b
  return a*b
```


```python
result = add_and_mul(2, 3)
```


```python
# 순서대로 처리하기 때문에 첫 return 문장만 return 해줌
# 반환값은 무조건 한 개

print(result)
```

    5


### **return을 활용하여 함수를 즉시 빠져나가기**


```python
# 반환값은 없음
# (문자열을 출력하기는 하지만 return이 받는 게 없으므로 반환값은 없음)

def say_nick(nick):
  if nick == "바보":
    return
  print("나의 별명은 %s 입니다." % nick)
```


```python
say_nick("야호")
```

    나의 별명은 야호 입니다.



```python
# if문에 걸려서 return을 통해 함수를 즉시 빠져나가게 됨
say_nick("바보")
```

### **매개변수에 초깃값 미리 설정**


```python
# 매개변수 name, age, man = False
# man = False: 매개변수에 미리 값을 넣어둠

def say_myself(name, age, man = False):
    print("나의 이름은 %s 입니다." % name)
    print("나이는 %d살입니다." % age)
    if man:
        print("남자입니다.")
    else:
        print("여자입니다.")
```


```python
# 미리 값을 넣어둔 대로 False(초기값)에 해당하는 문장이 출력

say_myself("박지인", 26)
```

    나의 이름은 박지인 입니다.
    나이는 26살입니다.
    여자입니다.



```python
# 함수에 False를 넣어둔 것과 동일한 결과

say_myself("박지인", 26, False)
```

    나의 이름은 박지인 입니다.
    나이는 26살입니다.
    여자입니다.


### **주의점**


```python
# 오류 발생
# SyntaxError: parameter without a default follows parameter with a default
# SyntaxError: non-default argument follows default argument
# 초기값이 없는 매개변수(age)는 초기값이 있는 매개변수(man) 뒤에 사용불가

# 즉, name, age, man = True 식으로 초기값이 있는 매개변수를 항상 뒤에 놓아야 함


def say_myself(name, man=True, age):
    print("나의 이름은 %s 입니다." % name)
    print("나이는 %d살입니다." % age)
    if man:
        print("남자입니다.")
    else:
        print("여자입니다.")
```


      File "/tmp/ipython-input-467900476.py", line 3
        def say_myself(name, man=True, age):
                                       ^
    SyntaxError: parameter without a default follows parameter with a default



### **함수 안에서 사용하는 변수의 이음을 함수 밖에서 사용하면?**


```python
# 매개변수 a

a = 1                         # a에 1 대입
def vartest(a):               # a를 매개변수로 다시 사용, a에 1을 더하고 return하지 않는 함수 정의
    a = a +1

vartest(a)
print(a)                      # 2가 아닌 1이 나옴
```

    1


* **함수 안에서만 사용하는 매개변수 a는 함수 밖의 a에 영향을 주지 못함!**


```python
def vartest(a):
    a = a + 1

vartest(3)
print(a)
```

    1


* **만약 에디터로 작성한다면 오류 발생**
* vartest 함수 안에서는 vartest(3)을 수행할 때 a가 4가 됨
* 하지만 함수를 호출하고 난 뒤 a를 프린트하려면 함수 밖에 a가 정의되어 있지 않기에 오류 발생
* **함수 안에서 선언한 매개변수는 함수 안에서만 쓴다**

### **함수 안에서 함수 밖의 변수 변경**

### **1. return 사용 (권장)**


```python
a = 1
def vartest(a):
    a = a + 1
    return a                        # 여기서 함수 안의 매개변수 a를

a = vartest(a)                      # 함수 밖의 a에 vartest 함수 안의 값을 대입
print(a)                            # 하지만 함수 밖 a는 함수 안 a와 다른 것
```

    2


### **2. global(전역변수) 사용**
* 사용하지 않는 것을 권장
* 함수가 독립적으로 존재하지 못하고 종속적인 함수가 됨


```python
a = 1
def vartest():
    global a
    a = a + 1

vartest()
print(a)
```

    2


### **list와 dict**
* list, dict와 같은 자료형은 함수 안에서 변경 가능


```python
def change_list(my_list):
  my_list.append(4)  # 리스트에 값을 추가
```


```python
a = [1, 2, 3]
```


```python
change_list(a)
```


```python
print(a)
```

    [1, 2, 3, 4]


* 함수에서 list.append(4)를 했을 때 원래 list인 a도 바뀜
* list는 변경 가능한 "자료형"
* dict에도 똑같이 적용
* **list와 dict을 함수에 전달하면 원본값이 바뀔 수 있으니 주의**

## **lambda 예약어**
* 함수를 생성할 때 사용하는 예약어
* def와 동일한 역할, 함수가 한 줄로 간결할 때 혹은 def를 사용할 수 없는 곳에 사용

```
함수_이름 = lambda 매개변수1, 매개변수2, ... : 매개변수를_이용한_표현식
```


```python
add = lambda a, b: a + b              # 매개변수 a, b를 더해주는 함수 add (lambda 사용)
result = add(3, 4)
```


```python
print(result)
```

    7


### **독스트링(Docstring)**



```
# 주석
```



```
"""

독스트링

"""
```




```python
a = b + 3

"""

a는 b에 3을 더한 값

"""
```

#**클래스(class)와 인스턴스(instance, 객체)**
* 실제로 존재하는 실체가 인스턴스, 객체들의 공통점을 간추려서 개념적으로 나타낸 것이 클래스
* ex: 강아지, 고양이(인스턴스) - 동물(클래스)


출처: https://wikidocs.net/85


```python
class Singer:                    # 가수를 정의, 클래스 이름 "Singer"
  def sing(self):                # 메서드 sing (클래스 내부에 정의된 함수)
    return "Lalala~"             # 메서드 sing: 'Lalala~'를 출력하도록 정의함
```


```python
taeji = Singer()                 # "taeji"라는 객체(인스턴스)가 클래스 "Singer"에 속하게 됨
taeji.sing()                     # 그러므로 클래스 내에 정의한 함수 메서드 sing을 사용할 수 있음
```




    'Lalala~'



# **변수와 메서드**


```python
class Amazon:                   # Amazon 클래스
    strength = 20               # 아마존 클래스가 갖고 있는 네 가지 변수
    dexterity = 25
    vitality = 20
    energy = 15

    def attack(self):           # attack 메서드
        return 'Jab!!!'
```


```python
jane = Amazon()                 # Amazon 클래스의 객체 jane과 mary
mary = Amazon()
```


```python
jane.strength                   # 객체는 Amazon 클래스의 속성을 모두 갖게 됨
```




    20




```python
jane.attack()
```




    'Jab!!!'



#**self**

* Amazon 클래스에서 메서드를 정의할 때 def attack(self):와 같이 self라는 인자를 받음
* jane 객체의 메서드를 호출할 때는 attack()이라고 함

 * 여러 객체(jane과 mary)가 똑같은 attack 메서드를 가지기 때문에 서로 구별하기 위해서 사용
 * 메서드를 정의할 때는 대부분 항상 **self**라는 인자 사용

#**상속(inheritance)**
* 다른 클래스로부터 핵심적인 성질을 상속을 받아서 다른 클래스를 만듦
* 클래스에 추후 다른 속성을 추가하고 싶을 때 그때마다 각각 수정해야 할 필요없음!


```python
class Person:                 # 사람을 표현하는 클래스 만들기
    eyes = 2                  # 눈 2개
    nose = 1                  # 코 하나
    mouth = 1                 # 입 하나
    ears = 2                  # 귀 2개
    arms = 2                  # 팔 2개
    legs = 2                  # 다리 2개

    def eat(self):
        print('얌냠...')

    def sleep(self):
        print('쿨쿨...')

    def talk(self):
        print('주절주절...')
```


```python
class Student(Person):     # Person 클래스를 상속받은 Student 클래스
    def study(self):
        print('열공열공...')
```

![image.png](data:image/png;base64,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)

### **각각 클래스의 관계 보기**


```python
lee = Person()
lee.mouth
```




    1




```python
lee.talk()
```

    주절주절...



```python
kim = Student()
kim.mouth
kim.talk()
```

    주절주절...



```python
kim.study()
```

    열공열공...



```python
lee.study()
```

# **객체 속의 객체**
* 코끼리를 냉장고에 넣기
* Fridge 클래스의 객체는 Food 클래스의 객체(elephant 등)을 여러 개 가질 수 있음


```python
class Fridge:
    def __init__(self):                         # 기본값 설정하기
        self.isOpened = False                   # isOpened 변수로 문이 열렸는지 닫혔는지 나타냄
        self.foods = []                         # 냉장고 안에 들어있는 음식들의 리스트

    def open(self):                             # open 메서드
        self.isOpened = True                    # 냉장고 문 열기
        print('냉장고 문을 연다')

    def put(self, thing):                       # put 메서드
        if self.isOpened:                       # open이 되어있으면 음식을 추가
            self.foods.append(thing)
            print('냉장고 속에 음식이 들어감')
        else:                                   # 아님 닫힘
            print('냉장고 문이 닫혀있음')

    def close(self):                            # close 메서드
        self.isOpened = False                   # 냉장고 문 닫기
        print('냉장고 문을 닫는다')

class Food:
    pass
```


```python
f = Fridge()
apple = Food()
elephant = Food()
```


```python
f.open()
```

    냉장고 문을 연다



```python
f.put(apple)
```

    냉장고 속에 음식이 들어감



```python
f.put(elephant)
```

    냉장고 속에 음식이 들어감



```python
f.foods
```




    [<__main__.Food at 0x7eae6a303a70>, <__main__.Food at 0x7eae6b6a0c20>]



# **특별한 메서드들**


```python
# __init__ 메서드 (초기화, 초기값/기본값 설정하기)
# 어떤 클래스의 객체가 만들어질 때 자동으로 호출,그 객체가 갖게 될 여러 가지 성질을 정해줌

class Book:

    def setData(self, title, price, author):
        self.title = title
        self.price = price
        self.author = author

    def printData(self):
        print('제목 : ', self.title)
        print('가격 : ', self.price)
        print('저자 : ', self.author)

    def __init__(self):
        print('책 객체 만들기')
```


```python
b = Book()
```

    책 객체 만들기



```python
b.setData('누가 내 치즈를 먹었을까', '300원', '미키')       # 값 넣기
```


```python
b.printData()
```

    제목 :  누가 내 치즈를 먹었을까
    가격 :  300원
    저자 :  미키



```python
class Book:

    def setData(self, title, price, author):
        self.title = title
        self.price = price
        self.author = author

    def printData(self):
        print('제목 : ', self.title)
        print('가격 : ', self.price)
        print('저자 : ', self.author)

    def __init__(self, title, price, author):
        self.setData(title, price, author)
        print('책 객체 만들기')
```


```python
b2 = Book('내가 먹었지롱', '200원', '미니')             # 아무것도 안 넣었을 때 init이 출력된 걸 확인
```

    책 객체 만들기



```python
# __del__ 메서드 (소멸자)
# 어떤 클래스의 객체가 객체가 없어질 때 호출되는 메서드

class Book:
    def __init__(self, title):
        self.title = title
        print(f"'{self.title}' 책 객체 생성")

    def __del__(self):
        print(f"'{self.title}' 책 객체 삭제")
```


```python
b1 = Book("파이썬 연습")                                # 객체 생성
```

    '파이썬 연습' 책 객체 생성



```python
del b1                                                  # 객체 삭제 - 객체가 없어질 때 __del__이 알려줌
```

    '파이썬 연습' 책 객체 삭제



```python
# __repr__ 메서드 (문자열을 return)

class Book:                                             # 하기 전에 클래스 먼저 만들기
    def __init__(self, title, price):
        self.title = title
        self.price = price

    def __repr__(self):
        return f"Book(title='{self.title}', price={self.price})"       # return 사용!
```


```python
b1 = Book("파이썬 기초", 20000)
```


```python
print(b1)                                               # __repr__ 호출
```

    Book(title='파이썬 기초', price=20000)



```python
# __add__ 메서드 (덧셈)

class Shape:

  area = 0

  def __add__(self, other):
    return self.area + other.area
```


```python
a = Shape()
a.area = 20
```


```python
b = Shape()
b.area = 10
```


```python
a + b
```




    30




```python
a.__add__(b)                                  # add 메서드 호출
```




    30



* 연산자 중복(overload): 메서드를 사용해 연산자가 하는 일을 정의
* 파이썬에서 자체적으로 제공하는 함수처럼 사용자가 직접 만든 클래스의 객체에 대해서 연산자를 쓸 수 있게 됨


```python
# __It__메서드 (비교)

class Shape:
  def __lt__(self, other):
        return self.area < other.area
  def __Gt__(self, other):                    # 비교 메서드 따로 만들어야 함...
        return self.area > other.area
```


```python
c = Shape()
c.area = 30
```


```python
d = Shape()
d.area = 20
```


```python
c > d
```




    True




```python
if c > d:
  print('c가 더 넓음')
```

    c가 더 넓음

